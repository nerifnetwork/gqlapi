// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type ActionConfigParams interface {
	IsActionConfigParams()
}

// BaseStep represents the base step model
type BaseStep interface {
	IsBaseStep()
	// id of the step
	GetID() string
	// type of the step
	GetType() StepType
	// parentSteps contains list of parent steps
	GetParentSteps() []*ParentStepRelation
	// childSteps contains the list of child steps
	GetChildSteps() []*ChildStepRelation
	// exitOnError indicates of the workflow should be exited if the current step is failed
	GetExitOnError() bool
	// metadata contains any data with any type
	GetMetadata() map[string]interface{}
}

// Condition is the common condition definition
type Condition interface {
	IsCondition()
}

// Step is the union of all possible steps
type Step interface {
	IsStep()
}

type TriggerConfigParams interface {
	IsTriggerConfigParams()
}

// ActionStep implements BaseStep with ACTION step type configuration
type ActionStep struct {
	// id of the step
	ID string `json:"id"`
	// type of the step
	Type StepType `json:"type"`
	// config is the configuration data of the ACTION step type
	Config *ActionStepConfig `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelation `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelation `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

func (ActionStep) IsStep() {}

func (ActionStep) IsBaseStep() {}

// id of the step
func (this ActionStep) GetID() string { return this.ID }

// type of the step
func (this ActionStep) GetType() StepType { return this.Type }

// parentSteps contains list of parent steps
func (this ActionStep) GetParentSteps() []*ParentStepRelation {
	if this.ParentSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ParentStepRelation, 0, len(this.ParentSteps))
	for _, concrete := range this.ParentSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// childSteps contains the list of child steps
func (this ActionStep) GetChildSteps() []*ChildStepRelation {
	if this.ChildSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ChildStepRelation, 0, len(this.ChildSteps))
	for _, concrete := range this.ChildSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// exitOnError indicates of the workflow should be exited if the current step is failed
func (this ActionStep) GetExitOnError() bool { return this.ExitOnError }

// metadata contains any data with any type
func (this ActionStep) GetMetadata() map[string]interface{} { return this.Metadata }

type ActionStepConfig struct {
	// action is the kind of action
	Action StepActionKind `json:"action"`
	// outputField contains the name of the output field
	OutputField string `json:"outputField"`
	// params contains action parameters
	Params ActionConfigParams `json:"params"`
}

type ActionStepConfigInput struct {
	// action is the kind of action
	Action StepActionKind `json:"action"`
	// outputField contains the name of the output field
	OutputField string `json:"outputField"`
	// ethCallParams contains eth_call action parameters
	EthCallParams *EthCallActionConfigParamsInput `json:"ethCallParams"`
	// ethTxParams contains eth_tx action parameters
	EthTxParams *EthTxActionConfigParamsInput `json:"ethTxParams"`
	// httpRequestParams contains HTTP request action parameters
	HTTPRequestParams *HTTPRequestActionConfigParamsInput `json:"httpRequestParams"`
}

// ActionStepInput is the input representation of ActionStep
type ActionStepInput struct {
	// id of the step
	ID string `json:"id"`
	// config is the configuration data of the ACTION step type
	Config *ActionStepConfigInput `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelationInput `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelationInput `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

type BlockTriggerConfigParams struct {
	ChainID int    `json:"chainID"`
	Period  string `json:"period"`
}

func (BlockTriggerConfigParams) IsTriggerConfigParams() {}

type BlockTriggerConfigParamsInput struct {
	ChainID int    `json:"chainID"`
	Period  string `json:"period"`
}

// ChildStepRelation is the step info about a child step
type ChildStepRelation struct {
	// id is the step identifier
	ID string `json:"id"`
	// executeOnError indicates if the step with the given ID must be executed if parent step is failed
	ExecuteOnError bool `json:"executeOnError"`
	// conditions is the list of conditions to be met in order to execute child step
	Conditions []Condition `json:"conditions"`
}

// ChildStepRelationInput is the input representation of ChildStepRelation
type ChildStepRelationInput struct {
	// id is the step identifier
	ID string `json:"id"`
	// executeOnError indicates if the step with the given ID must be executed if parent step is failed
	ExecuteOnError bool `json:"executeOnError"`
	// conditions is the list of conditions to be met in order to execute child step
	Conditions []*ConditionPureInput `json:"conditions"`
}

// ConditionGroup contains condition group configiration.
type ConditionGroup struct {
	// conditionOperator is basically condition operator
	ConditionOperator ConditionOperator `json:"conditionOperator"`
	// conditions is the list of conditions
	Conditions []Condition `json:"conditions"`
}

func (ConditionGroup) IsCondition() {}

// ConditionGroupInput is the input representation of ConditionGroup.
type ConditionGroupInput struct {
	// conditionOperator is basically condition operator
	ConditionOperator ConditionOperator `json:"conditionOperator"`
	// pureConditions is the list of pure conditions
	PureConditions []*ConditionPureInput `json:"pureConditions"`
	// groupConditions is the list of group conditions
	GroupConditions []*ConditionGroupInput `json:"groupConditions"`
}

// Condition contains condition configiration.
// E.g. 1 (left) == (condition) 1 (right).
type ConditionPure struct {
	// left is the left side of the condition
	Left interface{} `json:"left"`
	// operator is basically condition operator
	Operator string `json:"operator"`
	// right is the right side of the condition
	Right interface{} `json:"right"`
}

func (ConditionPure) IsCondition() {}

// ConditionPureInput is the input representation of StepCondition
type ConditionPureInput struct {
	// left is the left side of the condition
	Left interface{} `json:"left"`
	// operator is basically condition operator
	Operator string `json:"operator"`
	// right is the right side of the condition
	Right interface{} `json:"right"`
}

// ConditionStep implements BaseStep with CONDITION step type configuration
type ConditionStep struct {
	// id of the step
	ID string `json:"id"`
	// type of the step
	Type StepType `json:"type"`
	// config is the configuration data of the CONDITION step type
	Config *ConditionStepConfig `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelation `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelation `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

func (ConditionStep) IsStep() {}

func (ConditionStep) IsBaseStep() {}

// id of the step
func (this ConditionStep) GetID() string { return this.ID }

// type of the step
func (this ConditionStep) GetType() StepType { return this.Type }

// parentSteps contains list of parent steps
func (this ConditionStep) GetParentSteps() []*ParentStepRelation {
	if this.ParentSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ParentStepRelation, 0, len(this.ParentSteps))
	for _, concrete := range this.ParentSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// childSteps contains the list of child steps
func (this ConditionStep) GetChildSteps() []*ChildStepRelation {
	if this.ChildSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ChildStepRelation, 0, len(this.ChildSteps))
	for _, concrete := range this.ChildSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// exitOnError indicates of the workflow should be exited if the current step is failed
func (this ConditionStep) GetExitOnError() bool { return this.ExitOnError }

// metadata contains any data with any type
func (this ConditionStep) GetMetadata() map[string]interface{} { return this.Metadata }

type ConditionStepConfig struct {
	// outputField contains the name of the output field
	OutputField string `json:"outputField"`
	// condition contains a conditions
	Condition Condition `json:"condition"`
}

type ConditionStepConfigInput struct {
	// outputField contains the name of the output field
	OutputField string `json:"outputField"`
	// pureCondition contains a pure condition
	PureCondition *ConditionPureInput `json:"pureCondition"`
	// groupCondition a conditions group
	GroupCondition *ConditionGroupInput `json:"groupCondition"`
}

// ConditionStepInput is the input representation of ConditionStep
type ConditionStepInput struct {
	// id of the step
	ID string `json:"id"`
	// config is the configuration data of the CONDITION step type
	Config *ConditionStepConfigInput `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelationInput `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelationInput `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

type CronTriggerConfigParams struct {
	Rule string `json:"rule"`
}

func (CronTriggerConfigParams) IsTriggerConfigParams() {}

type CronTriggerConfigParamsInput struct {
	Rule string `json:"rule"`
}

type EthCallActionConfigParams struct {
	ChainID  int                    `json:"chainID"`
	Contract string                 `json:"contract"`
	FuncAbi  string                 `json:"funcABI"`
	Params   map[string]interface{} `json:"params"`
	GasLimit int                    `json:"gasLimit"`
}

func (EthCallActionConfigParams) IsActionConfigParams() {}

type EthCallActionConfigParamsInput struct {
	ChainID  int                    `json:"chainID"`
	Contract string                 `json:"contract"`
	FuncAbi  string                 `json:"funcABI"`
	Params   map[string]interface{} `json:"params"`
	GasLimit int                    `json:"gasLimit"`
}

type EthTxActionConfigParams struct {
	ChainID  int                    `json:"chainID"`
	Contract string                 `json:"contract"`
	FuncAbi  string                 `json:"funcABI"`
	Params   map[string]interface{} `json:"params"`
	GasLimit int                    `json:"gasLimit"`
}

func (EthTxActionConfigParams) IsActionConfigParams() {}

type EthTxActionConfigParamsInput struct {
	ChainID  int                    `json:"chainID"`
	Contract string                 `json:"contract"`
	FuncAbi  string                 `json:"funcABI"`
	Params   map[string]interface{} `json:"params"`
	GasLimit int                    `json:"gasLimit"`
}

type EventTriggerConfigParams struct {
	ChainID  int     `json:"chainID"`
	Contract string  `json:"contract"`
	EventAbi *string `json:"eventABI"`
	TopicID  *string `json:"topicID"`
}

func (EventTriggerConfigParams) IsTriggerConfigParams() {}

type EventTriggerConfigParamsInput struct {
	ChainID  int     `json:"chainID"`
	Contract string  `json:"contract"`
	EventAbi *string `json:"eventABI"`
	TopicID  *string `json:"topicID"`
}

// ExitStep implements BaseStep with EXIT step type configuration
type ExitStep struct {
	// id of the step
	ID string `json:"id"`
	// type of the step
	Type StepType `json:"type"`
	// config is the configuration data of the EXIT step type
	Config *ExitStepConfig `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelation `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelation `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

func (ExitStep) IsStep() {}

func (ExitStep) IsBaseStep() {}

// id of the step
func (this ExitStep) GetID() string { return this.ID }

// type of the step
func (this ExitStep) GetType() StepType { return this.Type }

// parentSteps contains list of parent steps
func (this ExitStep) GetParentSteps() []*ParentStepRelation {
	if this.ParentSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ParentStepRelation, 0, len(this.ParentSteps))
	for _, concrete := range this.ParentSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// childSteps contains the list of child steps
func (this ExitStep) GetChildSteps() []*ChildStepRelation {
	if this.ChildSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ChildStepRelation, 0, len(this.ChildSteps))
	for _, concrete := range this.ChildSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// exitOnError indicates of the workflow should be exited if the current step is failed
func (this ExitStep) GetExitOnError() bool { return this.ExitOnError }

// metadata contains any data with any type
func (this ExitStep) GetMetadata() map[string]interface{} { return this.Metadata }

type ExitStepConfig struct {
	// notes contains exit step notes
	Notes *string `json:"notes"`
}

type ExitStepConfigInput struct {
	// notes contains exit step notes
	Notes *string `json:"notes"`
}

// ExitStepInput is the input representation of ExitStep
type ExitStepInput struct {
	// id of the step
	ID string `json:"id"`
	// config is the configuration data of the EXIT step type
	Config *ExitStepConfigInput `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelationInput `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelationInput `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

type HTTPRequestActionConfigParams struct {
	Method  string `json:"method"`
	Address string `json:"address"`
	Timeout int    `json:"timeout"`
}

func (HTTPRequestActionConfigParams) IsActionConfigParams() {}

type HTTPRequestActionConfigParamsInput struct {
	Method  string `json:"method"`
	Address string `json:"address"`
	Timeout int    `json:"timeout"`
}

// ParentStepRelation is the step info about a parent step
type ParentStepRelation struct {
	// id is the step identifier
	ID string `json:"id"`
	// executeOnError indicates if the step with the given ID must be executed if parent step is failed
	ExecuteOnError bool `json:"executeOnError"`
}

// ParentStepRelationInput is the input representation of ParentStepRelation
type ParentStepRelationInput struct {
	// id is the step identifier
	ID string `json:"id"`
	// executeOnError indicates if the step with the given ID must be executed if parent step is failed
	ExecuteOnError bool `json:"executeOnError"`
}

// StepInput is the union of all possible step inputs.
type StepInput struct {
	Type          StepType            `json:"type"`
	TriggerStep   *TriggerStepInput   `json:"triggerStep"`
	ActionStep    *ActionStepInput    `json:"actionStep"`
	ConditionStep *ConditionStepInput `json:"conditionStep"`
	ExitStep      *ExitStepInput      `json:"exitStep"`
}

// TriggerStep implements BaseStep with TRIGGER step type configuration
type TriggerStep struct {
	// id of the step
	ID string `json:"id"`
	// type of the step
	Type StepType `json:"type"`
	// config is the configuration data of the TRIGGER step type
	Config *TriggerStepConfig `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelation `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelation `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

func (TriggerStep) IsStep() {}

func (TriggerStep) IsBaseStep() {}

// id of the step
func (this TriggerStep) GetID() string { return this.ID }

// type of the step
func (this TriggerStep) GetType() StepType { return this.Type }

// parentSteps contains list of parent steps
func (this TriggerStep) GetParentSteps() []*ParentStepRelation {
	if this.ParentSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ParentStepRelation, 0, len(this.ParentSteps))
	for _, concrete := range this.ParentSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// childSteps contains the list of child steps
func (this TriggerStep) GetChildSteps() []*ChildStepRelation {
	if this.ChildSteps == nil {
		return nil
	}
	interfaceSlice := make([]*ChildStepRelation, 0, len(this.ChildSteps))
	for _, concrete := range this.ChildSteps {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// exitOnError indicates of the workflow should be exited if the current step is failed
func (this TriggerStep) GetExitOnError() bool { return this.ExitOnError }

// metadata contains any data with any type
func (this TriggerStep) GetMetadata() map[string]interface{} { return this.Metadata }

type TriggerStepConfig struct {
	// trigger is the kind of trigger
	Trigger StepTriggerKind `json:"trigger"`
	// outputField is the variable name
	OutputField string `json:"outputField"`
	// params contains trigger parameters
	Params TriggerConfigParams `json:"params"`
}

type TriggerStepConfigInput struct {
	// trigger is the kind of trigger
	Trigger StepTriggerKind `json:"trigger"`
	// outputField is the variable name
	OutputField string `json:"outputField"`
	// blockParams contains block trigger parameters
	BlockParams *BlockTriggerConfigParamsInput `json:"blockParams"`
	// eventParams contains event trigger parameters
	EventParams *EventTriggerConfigParamsInput `json:"eventParams"`
	// cronParams contains cron trigger parameters
	CronParams *CronTriggerConfigParamsInput `json:"cronParams"`
}

// TriggerStepInput is the input representation of TriggerStep
type TriggerStepInput struct {
	// id of the step
	ID string `json:"id"`
	// config is the configuration data of the TRIGGER step type
	Config *TriggerStepConfigInput `json:"config"`
	// parentSteps contains list of parent steps
	ParentSteps []*ParentStepRelationInput `json:"parentSteps"`
	// childSteps contains the list of child steps
	ChildSteps []*ChildStepRelationInput `json:"childSteps"`
	// exitOnError indicates of the workflow should be exited if the current step is failed
	ExitOnError bool `json:"exitOnError"`
	// metadata contains any data with any type
	Metadata map[string]interface{} `json:"metadata"`
}

// Workflow represents the high level workflow model
type Workflow struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Steps       []Step                 `json:"steps"`
	Metadata    map[string]interface{} `json:"metadata"`
	State       WorkflowState          `json:"state"`
	Owner       string                 `json:"owner"`
	CreatedAt   time.Time              `json:"createdAt"`
	UpdatedAt   time.Time              `json:"updatedAt"`
}

// WorkflowExecution represents the high level workflow execution model
type WorkflowExecution struct {
	ID         string                  `json:"id"`
	WorkflowID string                  `json:"workflowID"`
	Status     WorkflowExecutionStatus `json:"status"`
	Metadata   *WorkflowExecutionMeta  `json:"metadata"`
	CreatedAt  time.Time               `json:"createdAt"`
	UpdatedAt  time.Time               `json:"updatedAt"`
}

// WorkflowExecutionMeta represents the workflow execution metadata
type WorkflowExecutionMeta struct {
	Error    string                 `json:"Error"`
	Duration int                    `json:"Duration"`
	Store    map[string]interface{} `json:"Store"`
}

// WorkflowInput is the input used to create or update a workflow
type WorkflowInput struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Steps       []*StepInput           `json:"steps"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// ConditionOperator represents logical operators
type ConditionOperator string

const (
	ConditionOperatorAnd ConditionOperator = "AND"
	ConditionOperatorOr  ConditionOperator = "OR"
	ConditionOperatorXor ConditionOperator = "XOR"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorAnd,
	ConditionOperatorOr,
	ConditionOperatorXor,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorAnd, ConditionOperatorOr, ConditionOperatorXor:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// StepTriggerKind contains all kinds of actions
type StepActionKind string

const (
	StepActionKindEthCall StepActionKind = "ETH_CALL"
	StepActionKindEthTx   StepActionKind = "ETH_TX"
	StepActionKindHTTP    StepActionKind = "HTTP"
)

var AllStepActionKind = []StepActionKind{
	StepActionKindEthCall,
	StepActionKindEthTx,
	StepActionKindHTTP,
}

func (e StepActionKind) IsValid() bool {
	switch e {
	case StepActionKindEthCall, StepActionKindEthTx, StepActionKindHTTP:
		return true
	}
	return false
}

func (e StepActionKind) String() string {
	return string(e)
}

func (e *StepActionKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepActionKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepActionKind", str)
	}
	return nil
}

func (e StepActionKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// StepTriggerKind contains all kinds of triggers
type StepTriggerKind string

const (
	StepTriggerKindBlock StepTriggerKind = "BLOCK"
	StepTriggerKindEvent StepTriggerKind = "EVENT"
	StepTriggerKindCron  StepTriggerKind = "CRON"
)

var AllStepTriggerKind = []StepTriggerKind{
	StepTriggerKindBlock,
	StepTriggerKindEvent,
	StepTriggerKindCron,
}

func (e StepTriggerKind) IsValid() bool {
	switch e {
	case StepTriggerKindBlock, StepTriggerKindEvent, StepTriggerKindCron:
		return true
	}
	return false
}

func (e StepTriggerKind) String() string {
	return string(e)
}

func (e *StepTriggerKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepTriggerKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepTriggerKind", str)
	}
	return nil
}

func (e StepTriggerKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// StepType contains all available step types
type StepType string

const (
	StepTypeTrigger   StepType = "TRIGGER"
	StepTypeAction    StepType = "ACTION"
	StepTypeCondition StepType = "CONDITION"
	StepTypeExit      StepType = "EXIT"
)

var AllStepType = []StepType{
	StepTypeTrigger,
	StepTypeAction,
	StepTypeCondition,
	StepTypeExit,
}

func (e StepType) IsValid() bool {
	switch e {
	case StepTypeTrigger, StepTypeAction, StepTypeCondition, StepTypeExit:
		return true
	}
	return false
}

func (e StepType) String() string {
	return string(e)
}

func (e *StepType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepType", str)
	}
	return nil
}

func (e StepType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WorkflowState contains all available workflow states
type WorkflowExecutionStatus string

const (
	WorkflowExecutionStatusInProgress WorkflowExecutionStatus = "IN_PROGRESS"
	WorkflowExecutionStatusSuccess    WorkflowExecutionStatus = "SUCCESS"
	WorkflowExecutionStatusFail       WorkflowExecutionStatus = "FAIL"
)

var AllWorkflowExecutionStatus = []WorkflowExecutionStatus{
	WorkflowExecutionStatusInProgress,
	WorkflowExecutionStatusSuccess,
	WorkflowExecutionStatusFail,
}

func (e WorkflowExecutionStatus) IsValid() bool {
	switch e {
	case WorkflowExecutionStatusInProgress, WorkflowExecutionStatusSuccess, WorkflowExecutionStatusFail:
		return true
	}
	return false
}

func (e WorkflowExecutionStatus) String() string {
	return string(e)
}

func (e *WorkflowExecutionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowExecutionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowExecutionStatus", str)
	}
	return nil
}

func (e WorkflowExecutionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WorkflowState contains all available workflow states
type WorkflowState string

const (
	WorkflowStateDraft    WorkflowState = "DRAFT"
	WorkflowStateActive   WorkflowState = "ACTIVE"
	WorkflowStatePaused   WorkflowState = "PAUSED"
	WorkflowStateCanceled WorkflowState = "CANCELED"
)

var AllWorkflowState = []WorkflowState{
	WorkflowStateDraft,
	WorkflowStateActive,
	WorkflowStatePaused,
	WorkflowStateCanceled,
}

func (e WorkflowState) IsValid() bool {
	switch e {
	case WorkflowStateDraft, WorkflowStateActive, WorkflowStatePaused, WorkflowStateCanceled:
		return true
	}
	return false
}

func (e WorkflowState) String() string {
	return string(e)
}

func (e *WorkflowState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowState", str)
	}
	return nil
}

func (e WorkflowState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
